---
title: "Practica Dns"
date: 2020-12-03T13:47:57+01:00
draft: true
---

# Práctica: Servidor DNS

## Escenario

1. En nuestra red local tenemos un servidor Web que sirve dos páginas web: www.iesgn.org, departamentos.iesgn.org

2. Vamos a instalar en nuestra red local un servidor DNS (lo puedes instalar en el mismo equipo que tiene el servidor web)

3. Voy a suponer en este documento que el nombre del servidor DNS va a ser pandora.iesgn.org. El nombre del servidor de tu prácticas será tunombre.iesgn.org.

Para poder generar el escenario vamos a usar una maquina vagrant, la cual tiene el siguiente contenido:
```ruby
# -*- mode: ruby -*-
# vi: set ft=ruby :

$install_apache = <<-SCRIPT
sudo apt update 
sudo apt install apache2 -y
SCRIPT



Vagrant.configure("2") do |config|
  config.vm.box = "debian/buster64"
  config.vm.hostname = "maquinaDNS"
  config.vm.network :private_network, ip: "192.168.100.100"
  config.vm.provision 'shell', inline: $install_apache
end
```

Con el que vamos a instalar apache como servidor web donde vamos a tener dos localhost en la misma ip. Generamos dos fichero en los virtualhost de apache2 con el siguiente contenido:

```shell
#### Fichero de iesgn ####
<VirtualHost *:80>

        ServerName www.iesgn.es
        ServerAdmin webmaster@localhost
        DocumentRoot /srv/iesgn

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>

#### Fichero departamentos ####
<VirtualHost *:80>

        ServerName departamentos.iesgn.es
        ServerAdmin webmaster@localhost
        DocumentRoot /srv/departamentos

        ErrorLog ${APACHE_LOG_DIR}/error.log
        CustomLog ${APACHE_LOG_DIR}/access.log combined

</VirtualHost>
```




# Servidor DNSmasq

Instala el servidor dns dnsmasq en pandora.iesgn.org y configúralo para que los clientes puedan conocer los nombres necesarios.

Ahora vamos a realizar la instalacion para que, sin necesidad de usar resolucion estatica, podamos acceder a las paginas que hemos creado anteriorment por lo que debemos de instala el servidor dns llamado dnsmasq, para ello vamos a seguir los siguientes pasos:
```shell
#### Instalamos el paquete de dnsmasq ####
vagrant@maquinaDNS:~$ sudo apt install dnsmasq

#### Paramos el servicio para poder configurarlo ####
vagrant@maquinaDNS:~$ sudo systemctl stop dnsmasq.service

vagrant@maquinaDNS:~$ sudo systemctl status dnsmasq.service 
● dnsmasq.service - dnsmasq - A lightweight DHCP and caching DNS server
   Loaded: loaded (/lib/systemd/system/dnsmasq.service; enabled; vendor preset: enabled)
   Active: inactive (dead) since Tue 2020-11-17 18:29:39 GMT; 9s ago
```

AHora ya tendremos listo el servicio para configurarlo. El fichero de dicho servcio se encuentra en **/etc/dnsmasq.conf**. Una vez entremos debemos de descomentar la linea llamada **strict-order** con lo que, si el servidor dnsmasq no es capaz de resolver la peticion consulte en el fichero **/etc/resolv.conf**:
```shell
# By  default,  dnsmasq  will  send queries to any of the upstream
# servers it knows about and tries to favour servers to are  known
# to  be  up.  Uncommenting this forces dnsmasq to try each query
# with  each  server  strictly  in  the  order  they   appear   in
# /etc/resolv.conf
strict-order
```

```shell
strict-order

interface=eth1

address=/www.iesgn.es/192.168.100.100
address=/departamentos.iesgn.es/192.168.100.100

listen-address=192.168.100.1

listen-address=127.0.0.1
```

## Tarea 1

Modifica los clientes para que utilicen el nuevo servidor dns. Realiza una consulta a www.iesgn.org, y a www.josedomingo.org. Realiza una prueba de funcionamiento para comprobar que el servidor dnsmasq funciona como cache dns. Muestra el fichero hosts del cliente para demostrar que no estás utilizando resolución estática. Realiza una consulta directa al servidor dnsmasq. ¿Se puede realizar resolución inversa?.

Para ellod debemos de añadir a nuestro fichero de **/etc/resolv.conf** y debemos de añadir la ip de nuestro servidor dns, en este caso es la ip **192.168.100.100**:
```shell
# Generated by NetworkManager
search NetisRouter_64eeb719a5f2
nameserver 192.168.100.100
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.1.1
```

Asi, al realizar una consulta a nuestras paginas **www.iesgn.es** veremos que lo hace mediante el servidor DNS con ip 192.168.100.100 y lo mismo pasa al hacer una consulta a la pagina **www.josedomingo.org**:
```shell
francisco@debian10:~$ dig www.iesgn.es

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> www.iesgn.es
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 42955
;; flags: qr aa rd ra ad; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.iesgn.es.			IN	A

;; ANSWER SECTION:
www.iesgn.es.		0	IN	A	192.168.100.100

;; Query time: 1 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mié nov 18 19:01:49 CET 2020
;; MSG SIZE  rcvd: 57

#### Ahora a la pagina www.josedomingo.org ####
francisco@debian10:~$ dig www.josedomingo.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> www.josedomingo.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 45149
;; flags: qr rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 512
;; QUESTION SECTION:
;www.josedomingo.org.		IN	A

;; ANSWER SECTION:
www.josedomingo.org.	899	IN	CNAME	playerone.josedomingo.org.
playerone.josedomingo.org. 899	IN	A	137.74.161.90

;; Query time: 90 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mié nov 18 19:04:30 CET 2020
;; MSG SIZE  rcvd: 88
```

Ademas si en el **/etc/hosts** de nuestro servidor con dnsmasq ponemos algun direccion para resolucion estatica y esta la consultamos veremos que nos funcionara perfectamente:
```shell
#### /etc/hosts del servidor ####
...
192.168.100.192 www.prueba.com
...

#### Consulta desde el cliente ####
francisco@debian10:~$ dig www.prueba.com

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> www.prueba.com
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 19897
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
;; QUESTION SECTION:
;www.prueba.com.			IN	A

;; ANSWER SECTION:
www.prueba.com.		0	IN	A	192.168.100.192

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 17:43:50 CET 2020
;; MSG SIZE  rcvd: 59
```

# Servidor bind9

Desinstala el servidor dnsmasq del ejercicio anterior e instala un servidor dns bind9. Las características del servidor DNS que queremos instalar son las siguientes:

* El servidor DNS se llama pandora.iesgn.org y por supuesto, va a ser el servidor con autoridad para la zona iesgn.org.

* Vamos a suponer que tenemos un servidor para recibir los correos que se llame correo.iesgn.org y que está en la dirección x.x.x.200 (esto es ficticio).

* Vamos a suponer que tenemos un servidor ftp que se llame ftp.iesgn.org y que está en x.x.x.201 (esto es ficticio)

* Además queremos nombrar a los clientes.

* También hay que nombrar a los virtual hosts de apache: www.iesgn.org y departementos.iesgn.org

* Se tienen que configurar la zona de resolución inversa.

## Tarea 2

LO primero que debemos de hacer es instalar bind9 en nuestro servidor dns, pero antes debemos desinstalar el servidor dnsmasq que habiamos instalado anteriormente, para ello usamos el siguiente comando:
```shell
#### Desinstalamos dnsmasq ####
vagrant@maquinaDNS:~$ sudo apt --remove purge dnsmasq

#### Instalamos bind9 ####
vagrant@maquinaDNS:~$ sudo apt install bind9

#### Paramos el servicio para configurarlo ####
vagrant@maquinaDNS:~$ sudo systemctl stop bind9
```

Una vez hayamos llegado a este paso debemos de dirigirnos al fichero de configuracion para definir las zonas que vamos a tener en este servidor dns, en este caso vamos a tener dos, una que sera la zona de **iesgn.org** y otra que sera la inversa de esta. Para ello debemos de configurar el fichero **/etc/bind/named.conf.local** y debemos de añadir lo siguiente:
```shell
#### Configuracion del fichero named.conf.local ####
...
include "/etc/bind/zones.rfc1918";

zone "iesgn.org" {
        type master;
        file "/var/cache/bind/db.iesgn.org";
};

zone "100.168.192.in-addr.arpa" {
        type master;
        file "/var/cache/bind/db.192.168.100";
};
```

Donde estamos definiendo la zona **iesgn.org** y su inversa, le estamos indicando que sera de **tipo maestro** y que los ficheros de dichas zonas se encuentren en esa ruta indicada.

Vemos que hemos incluido un fichero llamado **zones.rfc1918** en la cual debemos de comentar la linea respecto a la ip de nuestra zona, en este caso la zona es la siguiente:
```shell
#### Zona que comentar ####
//zone "168.192.in-addr.arpa" { type master; file "/etc/bind/db.empty"; };
```

Una vez ya hayamos hecho todo lo anterior, reiniciamos el servicio para ver si nos da alguna falla en la sintaxis, si no es asi vamos a seguir con la configuracion.

Ahora que ya hemos definido las zona vamos a empezar a configurar dichas zonas, empezando por la zona de **iesgn.org**, para ello vamos a tomar como referencia el fichero llamado **db.empy** que vamos a usar como plantilla para definir nuestra zona:
```shell
#### Copiamos el fichero a la ruta donde le indicamos en la zona ####
vagrant@maquinaDNS:/etc/bind$ sudo cp db.empty /var/cache/bind/db.iesgn.org
```

Una vez lo tengamos vamos a empezar a modificarlo, lo primero sera definir cual es el servidor con privilegios sobre la zona, en este caso ese servidor se llama francisco.iesgn.org, por lo que lo definimos como un tipo **NS**:
```shell
#### Añadimos el registro NS ####
; BIND reverse data file for empty rfc1918 zone
;
; DO NOT EDIT THIS FILE - it is used for multiple zones.
; Instead, copy it, edit named.conf, and use that copy.
;
$TTL    86400
@       IN      SOA     francisco.iesgn.org. root.localhost. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                          86400 )       ; Negative Cache TTL
;
@       IN      NS      francisco.iesgn.org.

$ORIGIN iesgn.org.

francisco       IN      A       192.168.100.100
```

Donde vemos que:
* El registro SOA es la autoridad sobre la zona, en este caso **francisco.iesgn.org.**
* $ORIGIN Lo usamos para no tener que estar poniendo la zona **iesgn.org** por cada registro que vayamos creando.
* El registro de tipo A específica las direcciones IP correspondientes a tus dominios y subdominios.

Por lo que, si en nuestra maquina cliente añadimos en el fichero **/etc/resolv.conf** el servidor dns y hacemos una consulta para saber quien es el que tiene autoridad sobre la zona **iesgn.org** debe de contestarnos de la siguiente manera:
```shell
#### Consulta sobre autoridad en la zona iesgn.org ####
francisco@debian10:~$ dig ns iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> ns iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 38755
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 0, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: e8c4b07d8650abc802c3a7d35fbd3f327bc46b0082729acd (good)
;; QUESTION SECTION:
;iesgn.org.			IN	NS

;; ANSWER SECTION:
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:13:22 CET 2020
;; MSG SIZE  rcvd: 106
```

Ahora que ya tenemos nuestra autoridad sobre la zona pasemos a definir el servidor de correos que, aunque no lo tengamos, lo vamos a definir igualmente, para ello debemos de dirigirnos al fichero de configuracion de la zona **iesgn.org** y ahi debemos de añadir un registro **MX**:
```shell
#### Añadiendo el registro MX ####
$TTL    86400
@       IN      SOA     francisco.iesgn.org. root.localhost. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                          86400 )       ; Negative Cache TTL
;
@       IN      NS      francisco.iesgn.org.
@       IN      MX      10 correo.iesgn.org.

$ORIGIN iesgn.org.

francisco       IN      A       192.168.100.100
correo          IN      A       192.168.100.200
```

Donde vemos que hemos añadido el registro **MX** para el correo con esa direccion y que hemos definido un registro para identificar a **correo** con la ip 192.168.100.200. Ahora si nosotros hacemos una consulta al servidor dns y preguntamos sobre el servidor de correos **correo.iesgn.org** debe de aparecernos esto:
```shell
francisco@debian10:~$ dig mx iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> mx iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 51974
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 3

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: dc7fc9a6704245ca745a4fba5fbd415df5e693c62a52ffab (good)
;; QUESTION SECTION:
;iesgn.org.			IN	MX

;; ANSWER SECTION:
iesgn.org.		86400	IN	MX	10 correo.iesgn.org.

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
correo.iesgn.org.	86400	IN	A	192.168.100.200
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 1 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:22:37 CET 2020
;; MSG SIZE  rcvd: 145
```

Ahora vamos a añadir otro nombre mas a nuestra zona, en este caso va a ser **ftp** con una ip inventada ya que no existe realmente. Para esto seguimos el mismo proceso que hemos seguido en los anteriores registros:
```shell
#### Configuracion del fichero de nuestra zona ####
$TTL    86400
@       IN      SOA     francisco.iesgn.org. root.localhost. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                          86400 )       ; Negative Cache TTL
;
@       IN      NS      francisco.iesgn.org.
@       IN      MX      10 correo.iesgn.org.

$ORIGIN iesgn.org.

francisco       IN      A       192.168.100.100
correo          IN      A       192.168.100.200
ftp             IN      A       192.168.100.201
```

Ahora reiniciamos el servicio y en nuestra maquina cliente hacemos la consulta a esa direccion y nos debe dar un resultado como el siguiente:
```shell
#### Consulta a ftp.iesgn.org ####
francisco@debian10:~$ dig  ftp.iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> ftp.iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 21847
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: fd3343e73a81babf1068d7345fbd41f9bb49339ace7b3243 (good)
;; QUESTION SECTION:
;ftp.iesgn.org.			IN	A

;; ANSWER SECTION:
ftp.iesgn.org.		86400	IN	A	192.168.100.201

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:25:13 CET 2020
;; MSG SIZE  rcvd: 126
```

Ahora que ya sabemos como hacerlo vamos a añadir los registros que nos faltan, en este caso va a ser **client.iesgn.org** y los virtualhost de apache.
```shell
#### Configuracion de los sitios ####
$TTL    86400
@       IN      SOA     francisco.iesgn.org. root.localhost. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                          86400 )       ; Negative Cache TTL
;
@       IN      NS      francisco.iesgn.org.
@       IN      MX      10 correo.iesgn.org.

$ORIGIN iesgn.org.

francisco       IN      A       192.168.100.100
correo          IN      A       192.168.100.200
ftp             IN      A       192.168.100.201
cliente         IN      A       192.168.100.202
www             IN      CNAME   francisco
departamentos   IN      CNAME   francisco
```

Donde vemos que un registro **CNAME** específica las redirecciones desde los subdominios de los dominios a otros dominios / subdominios. Por lo que, si ahora intentamos entrar en las direcciones **www.iesgn.org** y en **departamentos.iesgn.org** nos debe de servir la pagina que tenemos en nuestro servidor sin necesidad de la resolucion estatica, ademas, si hacemos una consulta tambien nos debe de salir lo siguiente:
```shell
#### Consulta a www ####
francisco@debian10:~$ dig www.iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> www.iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 44300
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 79cd321b284934654b68522e5fbd43d067d37db98dad4f6d (good)
;; QUESTION SECTION:
;www.iesgn.org.			IN	A

;; ANSWER SECTION:
www.iesgn.org.		86400	IN	CNAME	francisco.iesgn.org.
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:33:04 CET 2020
;; MSG SIZE  rcvd: 124

#### Consulta a departamentos ####
francisco@debian10:~$ dig departamentos.iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> departamentos.iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 57359
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 1, ADDITIONAL: 1

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: d4f1ca0f2c59ac1f7c983a9c5fbd440863c5461abaf3b586 (good)
;; QUESTION SECTION:
;departamentos.iesgn.org.	IN	A

;; ANSWER SECTION:
departamentos.iesgn.org. 86400	IN	CNAME	francisco.iesgn.org.
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:34:00 CET 2020
;; MSG SIZE  rcvd: 134
```

### Configuracion de Zona inversa

AHora que ya tenemos nuestra zona configurada, vamos a pasar a la zona inversa para su configuracion, para ello debemos de ir al fichero que vamos a crear llamado **db.192.168.100**, para ello vamos a usar como plantilla el fichero llamado **/etc/bind/db.empy**:
```shell
#### Creamos el fichero db.192.168.100 ####
vagrant@maquinaDNS:/var/cache/bind$ sudo cp /etc/bind/db.127 ./db.192.168.100

#### Lo modificamos de la siguiente forma ####
$TTL    604800
@       IN      SOA     francisco.iesgn.org. root.localhost. (
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                         604800 )       ; Negative Cache TTL
;
@       IN      NS      francisco.iesgn.org.

$ORIGIN 100.168.192.in-addr.arpa.

100     IN      PTR     francisco.iesgn.org.
200     IN      PTR     correo.iesgn.org.
201     IN      PTR     ftp.iesgn.org.
202     IN      PTR     cliente.iesgn.org.
```

Donde vemos que, por cada registro **A** que tengamos en las zonas directas, debemos añadir un registro **PTR** que es un dominio que define las direcciones IP de todos los sistemas en una notación invertida. 

Si reiniciamos el servicio y nos dirigimos a nuestro cliente ya podremos hacer consultas inversas a nuestro servidor, para ello usamos la opcion **-x**:
```shell
#### Cosulta inversa a francisco.iesgn.org ####
francisco@debian10:~$ dig -x 192.168.100.100

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> -x 192.168.100.100
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 16129
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 1, ADDITIONAL: 2

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 3edadbfd5aaeeecfac9dcbbf5fbd46fc90fe55df9317d7e3 (good)
;; QUESTION SECTION:
;100.100.168.192.in-addr.arpa.	IN	PTR

;; ANSWER SECTION:
100.100.168.192.in-addr.arpa. 604800 IN	PTR	francisco.iesgn.org.

;; AUTHORITY SECTION:
100.168.192.in-addr.arpa. 604800 IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 1 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar nov 24 18:46:36 CET 2020
;; MSG SIZE  rcvd: 148
```

## Tarea 3

Para hacer esta tarea necesitamos otra maquina a la que vamos a llamar **esclavodns**, el fichero de vagrant quedaria asi:
```ruby
# -*- mode: ruby -*-
# vi: set ft=ruby :

$install_apache = <<-SCRIPT
sudo apt update 
sudo apt install apache2 -y
sudo apt install bind9
SCRIPT



Vagrant.configure("2") do |config|
  config.vm.define :maestro do |maestro|
    maestro.vm.box = "debian/buster64"
    maestro.vm.hostname = "maquinaDNS"
    maestro.vm.network :private_network, ip: "192.168.100.100"
    maestro.vm.provision 'shell', inline: $install_apache
  end
  config.vm.define :esclavo do |esclavo|
    esclavo.vm.box = "debian/buster64"
    esclavo.vm.hostname = "esclavodns"
    esclavo.vm.network :private_network, ip: "192.168.100.101"
    esclavo.vm.provision 'shell', inline: $install_apache
  end
end
```

Ahora lo que vamos a hacer es, en nuestra maquina maestra vamos a añadir a que maquina esclavo debe de transferir las zonas ya que nosotrso en ningun momento debemos de tocar la configuracion de las zonas en la maquina esclavo. Para ello debemos de añadir las siguientes lineas:
```shell
#### Por temas de seguridad debemos de tocar el fichero named.conf.options de nuestro servidor maestro ####
options {
  ...
  allow-transfer {none;};
  ...
}

#### Confirguracion del fichero named.conf.local de maestro ####
...
zone "iesgn.org" {
        type master;
        file "/var/cache/bind/db.iesgn.org";
        allow-transfer {192.168.100.101;};
        notify yes;
};

zone "100.168.192.in-addr.arpa" {
        type master;
        file "/var/cache/bind/db.192.168.100";
        allow-transfer {192.168.100.101;};
        notify yes;
...

#### Configuracion de named.conf.local en esclavo ####
include "/etc/bind/zones.rfc1918";

zone "iesgn.org" {
        type slave;
        file "/var/cache/bind/db.iesgn.org";
        masters {192.168.100.100;};
};

zone "100.168.192.in-addr.arpa" {
        type slave;
        file "/var/cache/bind/db.192.168.100";
        masters {192.168.100.100;};

};
```
Donde le estamos indicando al servidor maestro que solo puede hacer una transferencia de zonas a la ip que le hemos indicado, en este caso la ip corresponde a la maquina esclavo. Ademas añadimos la opción de **notify yes** con la que, si hay un cambio en el mestro se le notifique al servidor esclavo.


En cambio en el servidor esclavo debemos de decirle cual va a ser el servidor maestro de este en una zona dns concreta. Le indicamos el fichero donde va a tener la configuracion de las zonas pero **estos ficheros no los debemos de crear ya que se generan solos al hacer la peticion de transferencia de las zonas**.


De esta forma ya tendremos nuestro servidor esclavo y maestro configurados para poder funcionar perfectamente entre si, ahora vamos a comprobar que no haya errores de sintaxis de los ficheros de configuracion, para ello usamos el comando **named-checkconf**:
```shell
#### Ficheros del maestro ####
vagrant@maquinaDNS:/etc/bind$ sudo named-checkconf named.conf.local 
vagrant@maquinaDNS:/etc/bind$ sudo named-checkconf named.conf.options 

#### Ficherps del esclavo ####
vagrant@esclavodns:/etc/bind$ sudo named-checkconf named.conf.local 
vagrant@esclavodns:/etc/bind$ sudo named-checkconf named.conf.options 
```

Y ahora vamos a comprobar los ficheros de las zonas dns, esta vez solo en el maestro con el comando **named-checkzone**:
```shell
#### Comprobamos la zonas directas ####
vagrant@maquinaDNS:~$ sudo named-checkzone iesgn.org /var/cache/bind/db.iesgn.org 
zone iesgn.org/IN: loaded serial 2
OK

#### Comprobamos las zonas inversas ####
vagrant@maquinaDNS:~$ sudo named-checkzone 100.168.192 /var/cache/bind/db.192.168.100 
/var/cache/bind/db.192.168.100:17: ignoring out-of-zone data (100.100.168.192.in-addr.arpa)
/var/cache/bind/db.192.168.100:18: ignoring out-of-zone data (101.100.168.192.in-addr.arpa)
/var/cache/bind/db.192.168.100:19: ignoring out-of-zone data (200.100.168.192.in-addr.arpa)
/var/cache/bind/db.192.168.100:20: ignoring out-of-zone data (201.100.168.192.in-addr.arpa)
/var/cache/bind/db.192.168.100:21: ignoring out-of-zone data (202.100.168.192.in-addr.arpa)
zone 100.168.192/IN: loaded serial 2
OK
```


Y ahora vamos a mostrar los log que demuestran la transferencia:
```shell
#### Log de transferencia
...
Nov 25 13:41:25 buster named[3664]: transfer of '100.168.192.in-addr.arpa/IN' from 192.168.100.100#53: connected using 192.168.100.101#33051
Nov 25 13:41:25 buster named[3664]: transfer of 'iesgn.org/IN' from 192.168.100.100#53: connected using 192.168.100.101#49793
...
```

## Tarea 4

Para esta tarea debemos de tener en nuestro cliente las ip de los dos servidores dns, el esclavo y el maestro, de esta forma:
```shell
 Generated by NetworkManager
nameserver 192.168.100.100
nameserver 192.168.100.101
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 192.168.1.1
```

Y a la hora de hacer una consulta sobre la zona iesgn.org nos dara el siguiente resultado:
```shell
francisco@debian10:~$ dig ns iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> ns iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 29709
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 0, ADDITIONAL: 3

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 5235b2efd6f760b955c5ebc55fbe8947b6eaa84c7696582d (good)
;; QUESTION SECTION:
;iesgn.org.			IN	NS

;; ANSWER SECTION:
iesgn.org.		86400	IN	NS	esclavo.iesgn.org.
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
esclavo.iesgn.org.	86400	IN	A	192.168.100.101
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mié nov 25 17:41:43 CET 2020
;; MSG SIZE  rcvd: 144
```

Y vemos que nos da como resultado los dos servidores, el esclavo y el maestro, tecnicamente no deberiamos saber cual es cual pero los nombres que tienen los delatan. AHora vamos a intentar obtener una copia de las zonas de nuestro dns, para ello debemos de hacerlo desde nuestro servidor esclavo ya que desde neustro cliente no nos mostrar informacion sobre las zonas, como podemos ver aqui:
```shell
#### Desde el cliente ####
francisco@debian10:~$ dig @192.168.100.100 iesgn.org. axfr

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> @192.168.100.100 iesgn.org. axfr
; (1 server found)
;; global options: +cmd
; Transfer failed.

#### Desde el esclavo ####
vagrant@esclavodns:~$ dig @192.168.100.100 iesgn.org. axfr

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> @192.168.100.100 iesgn.org. axfr
; (1 server found)
;; global options: +cmd
iesgn.org.		86400	IN	SOA	francisco.iesgn.org. root.localhost. 2 604800 86400 2419200 86400
iesgn.org.		86400	IN	NS	esclavo.iesgn.org.
iesgn.org.		86400	IN	NS	francisco.iesgn.org.
iesgn.org.		86400	IN	MX	10 correo.iesgn.org.
cliente.iesgn.org.	86400	IN	A	192.168.100.202
correo.iesgn.org.	86400	IN	A	192.168.100.200
departamentos.iesgn.org. 86400	IN	CNAME	francisco.iesgn.org.
esclavo.iesgn.org.	86400	IN	A	192.168.100.101
francisco.iesgn.org.	86400	IN	A	192.168.100.100
ftp.iesgn.org.		86400	IN	A	192.168.100.201
www.iesgn.org.		86400	IN	CNAME	francisco.iesgn.org.
iesgn.org.		86400	IN	SOA	francisco.iesgn.org. root.localhost. 2 604800 86400 2419200 86400
;; Query time: 3 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: Wed Nov 25 16:46:24 GMT 2020
;; XFR size: 12 records (messages 1, bytes 359)
```

Ahora, si nosotros nos dirigimos al servidor maestro y paramos el servicio de dns y, posteriormente realizamos una consulta desde nuestro cliente debe de respondernos nuestro servidor esclavo en vez de nuestro servidor maestro:
```shell
#### Paramos el servicio en el servidor maestro ####
vagrant@maquinaDNS:~$ sudo systemctl stop bind9

#### Realizamos una consulta desde nuestro cliente ####
francisco@debian10:~$ dig mx iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> mx iesgn.org
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 48922
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 1, AUTHORITY: 2, ADDITIONAL: 4

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: 9c699f7a658d083de7104ac35fbf60f070acdd571678eb82 (good)
;; QUESTION SECTION:
;iesgn.org.			IN	MX

;; ANSWER SECTION:
iesgn.org.		86400	IN	MX	10 correo.iesgn.org.

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	esclavo.iesgn.org.
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
correo.iesgn.org.	86400	IN	A	192.168.100.200
esclavo.iesgn.org.	86400	IN	A	192.168.100.101
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 0 msec
;; SERVER: 192.168.100.101#53(192.168.100.101)
;; WHEN: jue nov 26 09:01:52 CET 2020
;; MSG SIZE  rcvd: 183
```

Y como podemos ver nos esta contestando el servidor con ip **192.168.100.101** que es nuestro dns esclavo.

## Tarea 5

Tenemos un servidor DNS que gestiona la zona correspondiente al nombre de dominio iesgn.org, en esta ocasión queremos delegar el subdominio informatica.iesgn.org para que lo gestione otro servidor DNS. Por lo tanto tenemos un escenario con dos servidores DNS:

* pandora.iesgn.org, es servidor DNS autorizado para la zona iesgn.org.

* ns.informatica.iesgn.org, es el servidor DNS para la zona informatica.iesgn.org y, está instalado en otra máquina.

Los nombres que vamos a tener en ese subdominio son los siguientes:

* www.informatica.iesgn.org corresponde a un sitio web que está alojado en el servidor web del departamento de informática.

* Vamos a suponer que tenemos un servidor ftp que se llame ftp.informatica.iesgn.org y que está en la misma máquina.

* Vamos a suponer que tenemos un servidor para recibir los correos que se llame correo.informatica.iesgn.org.

## Tarea 6

Realiza la instalación y configuración del nuevo servidor dns con las características anteriormente señaladas. Muestra el resultado al profesor.

Para ello lo que debemos de hacer es añadir el subdominio a nuestras zonas del dns maestro, para ello debemos de tener la siguiente linea añadida al fichero db.iesgn.org:
```shell
#### Lineas a añadir en el fichero db.iesgn.org del servidor maestro ####
...
$ORIGIN informatica.iesgn.org.
@       IN      NS      francisco2
www     IN      CNAME   francisco2
francisco2      IN      A       192.168.100.102
```

Como vemos mi nueva maquina tiene una ip la cual es **192.168.100.102** y es donde vamos a tener nuestro servidor dns el cual sera el servidor con autoridad sobre la zona **informatica.iesgn.org.**. 

Por esto debemos de crear una nueva maquina en nuestro fichero vagrant y añadirle la ip **192.168.100.102**, en esta maquina debemos de isntalar un servidor dns bind9 en el cual vamos a modificar el fichero **/etc/bind/named.conf.local** vamos a añadir la zona que vamos a usar, en mi caso es la siguiente zona:
```shell
zone "informatica.iesgn.org" {
        type master;
        file "db.informatica.iesgn.org";
};
```

Y debemos de crear un fichero llamado **/var/cache/bind/db.informatica.iesgn.org** en el cual vamos a dar las caracteristicas que va a tener la zona que controla nuestro servidor dns, en mi caso sera el siguiente:
```shell
$TTL    86400
@       IN      SOA     francisco2.informatica.iesgn.org. root.informatic$
                              1         ; Serial
                         604800         ; Refresh
                          86400         ; Retry
                        2419200         ; Expire
                          86400 )       ; Negative Cache TTL
;
@       IN      NS      francisco2.informatica.iesgn.org.
@       IN      MX      10 correo.informatica.iesgn.org.

$ORIGIN informatica.iesgn.org.
francisco2      IN      A       192.168.100.102
www     IN      CNAME   francisco2
ftp     IN      A       192.168.100.110
correo  IN      A       192.168.100.130
```

Una vez hecho esto reiniciamos los servicios de bind9 en las dos maquinas y en nuestra maquina cliente debemos de añadir a nuestro fichero **/etc/resolv.conf** la ip de nuestro servidor maestro y no de nuestro servidor con dominio sobre la zona **informatica.iesgn.org**:
```shell
#### Fichero /etc/resolv.conf ####
nameserver 192.168.100.100
```

Ahora ya podemos hacer consultas sobre la nueva zona a nuestro servidor y nos respondera con lo siguiente:
```shell
#### Preguntamos por el servidor con dominio sobre la zona www.informatica.iesgn.org
francisco@debian10:~$ dig @192.168.100.100 www.informatica.iesgn.org

; <<>> DiG 9.11.5-P4-5.1+deb10u2-Debian <<>> @192.168.100.100 www.informatica.iesgn.org
; (1 server found)
;; global options: +cmd
;; Got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 20384
;; flags: qr aa rd ra; QUERY: 1, ANSWER: 2, AUTHORITY: 2, ADDITIONAL: 3

;; OPT PSEUDOSECTION:
; EDNS: version: 0, flags:; udp: 4096
; COOKIE: c7d7bdffcab31bda512a6b855fc676504cfdc61b8e2a8971 (good)
;; QUESTION SECTION:
;www.informatica.iesgn.org.	IN	A

;; ANSWER SECTION:
www.informatica.iesgn.org. 86400 IN	CNAME	francisco2.informatica.iesgn.org.
francisco2.informatica.iesgn.org. 86400	IN A	192.168.100.102

;; AUTHORITY SECTION:
iesgn.org.		86400	IN	NS	esclavo.iesgn.org.
iesgn.org.		86400	IN	NS	francisco.iesgn.org.

;; ADDITIONAL SECTION:
esclavo.iesgn.org.	86400	IN	A	192.168.100.101
francisco.iesgn.org.	86400	IN	A	192.168.100.100

;; Query time: 0 msec
;; SERVER: 192.168.100.100#53(192.168.100.100)
;; WHEN: mar dic 01 17:58:56 CET 2020
;; MSG SIZE  rcvd: 201
```